# CORP 项目深度学习手册
> 主题：币本位期权理论与实践 + 数学理论与实践 + 算法理论与实践 + 工程理论与实践  
> 适用代码库：`<项目根目录>/corp`  
> 适用读者：希望从“能跑代码”提升到“能解释、能扩展、能审查、能上线”的工程/量化开发者

---

## 1. 项目定位与学习目标

### 1.1 这个项目本质上在做什么
CORP 是一个**面向加密货币期权（重点是币本位/inverse）**的研究与工程平台，覆盖完整链路：
1. 市场数据采集（REST + WebSocket）
2. 数据验证与缓存（Parquet + DuckDB + Redis）
3. 波动率、Greeks、风险模型
4. 做市与套利策略
5. 回测与策略对比
6. CI/部署/健康检查

它不是单点脚本，而是一个**“研究 -> 策略 -> 风控 -> 工程化运行”**的一体化框架。

### 1.2 你应该达到的能力目标
学习完成后，建议你能做到：
1. 数学上：独立推导并解释 inverse 期权定价/希腊值核心公式。
2. 算法上：能读懂并改造做市、对冲、波动率状态机、套利策略。
3. 工程上：能在不破坏系统稳定性的前提下新增数据源/策略/风控规则。
4. 交易上：知道每个模块如何影响实际 PnL、回撤、容量、延迟。

---

## 2. 全局架构：先建立“系统地图”

### 2.1 模块分层（按目录）
1. `core/`：统一类型、验证、健康检查、基础抽象。
2. `data/`：交易所下载器、流处理、缓存、数据管理。
3. `research/`：定价、Greeks、波动率、风控、回测。
4. `strategies/`：做市与套利策略实现。
5. `execution/`：服务入口与运行编排。
6. `tests/`：单元测试、集成测试、性能基准。
7. `deployment/`：容器化和生产部署文档/配置。

### 2.2 关键数据流
1. 交易所数据进入 `data/downloaders/*` 与 `data/streaming.py`。
2. 数据先过 `core/validation/*` 与 schema 约束。
3. 历史数据写入 Parquet (`data/cache.py`)；分析走 DuckDB (`data/duckdb_cache.py`)；实时热点走 Redis (`data/redis_cache.py`)。
4. 策略从 `core/types.py` 定义的 `MarketState/OrderBook/Greeks/Position` 消费数据并产出 `QuoteAction`。
5. 回测引擎 `research/backtest/engine.py` 做事件驱动仿真，最后输出风险收益指标。

---

## 3. 币本位期权：理论与实践（核心）

## 3.1 为什么 inverse 期权特殊
币本位（inverse）合约的计价与结算单位不同于 U 本位：
1. 价格常用 USD 报价。
2. 盈亏通常以币结算（或等效币本位机制）。
3. 结果是 PnL、Delta、Gamma 的量纲与直觉都不同。

代码中的核心实现在：
- `research/pricing/inverse_options.py`

### 3.2 核心 PnL 公式与直觉
项目实现中使用：
\[
\text{PnL}_{inverse} = \text{size} \cdot \left(\frac{1}{P_{entry}} - \frac{1}{P_{exit}}\right)
\]
对应代码可见：
- `research/pricing/inverse_options.py` 的 `calculate_pnl`
- `core/types.py` 的 `Position.unrealized_pnl(..., inverse=True)`

这意味着：
1. PnL 对价格是**非线性**（1/S 结构），不是线性差价。
2. 风险和收益的敏感性随价格水平变化。
3. 用线性 Delta 近似会在极端行情下系统性失真。

### 3.3 inverse 期权的定价公式（项目实现）
项目在 `InverseOptionPricer.calculate_price` 使用了 inverse 版本公式：
1. Inverse Call：
\[
C_{inv} = e^{-rT}\frac{1}{K}N(-d_2) - \frac{1}{S}N(-d_1)
\]
2. Inverse Put：
\[
P_{inv} = \frac{1}{S}N(d_1) - e^{-rT}\frac{1}{K}N(d_2)
\]
3. 且 d1,d2 不是标准 S/K 形式，而是 inverse 语义下的 K/S 结构。

你要特别注意：
1. `research/pricing/inverse_options.py` 对边界条件（T≈0）做了显式处理。
2. 输入合法性检查对数值稳定性非常关键（NaN/Inf/极端波动率）。

### 3.4 希腊字母：为什么不能直接套标准 BS
项目中 inverse Greeks 在 `InverseOptionPricer._calculate_greeks_from_d`。

关键点：
1. Delta/Gamma/Theta/Vega/Rho 的表达式都改写过。
2. Vega 在实现里有缩放因子（每 1% vol）与“每单位 vol”之间的转换。
3. implied vol 牛顿法中也考虑了该缩放（否则步长错误）。

实操建议：
1. 读完公式后，先跑 `tests/test_priority_fixes.py` 中与 Greeks 相关测试。
2. 再跑 `validation_scripts/` 下的数学验证脚本，观察误差与边界行为。

### 3.5 Put-Call parity（inverse 版本）
项目提供了 inverse parity 检验函数：
- `inverse_option_parity(...)` in `research/pricing/inverse_options.py`

这比普通 parity 更容易被实现细节弄错，尤其在：
1. 折现项
2. 量纲（1/K 与 1/S）
3. 到期边界

### 3.6 实践路线（建议顺序）
1. 先读 `research/pricing/inverse_options.py` 全文件。
2. 再读 `docs/archive/learning/inverse_options_math_proof.md`（注意其中部分推导说明可作为讨论起点，不要盲信文字结论，优先以代码+测试为准）。
3. 运行：
```bash
cd "<项目根目录>/corp"
./venv/bin/pytest -q tests/test_priority_fixes.py tests/test_pricing_inverse.py tests/test_pricing_boundary.py
./venv/bin/python validation_scripts/archive/inverse_pnl_math_validation.py
```
4. 选一个参数集手工复算 d1/d2 与 price，对齐实现。

---

## 4. 数学理论与实践（从模型到数值）

## 4.1 波动率估计：统计定义与代码映射
文件：`research/volatility/historical.py`

已实现：
1. Realized Variance/Volatility
2. Parkinson
3. Garman-Klass
4. Rogers-Satchell
5. Yang-Zhang

你需要理解三件事：
1. 各估计器需要哪些输入（close-only vs OHLC）。
2. 对漂移/跳空的敏感性差异。
3. 小样本偏差修正（如 Parkinson 的修正）。

实践建议：
1. 用同一段 OHLC 数据分别跑 5 种估计器。
2. 在高跳空样本比较 Yang-Zhang 与 close-only 估计偏差。

## 4.2 隐含波动率求解：数值方法学
文件：`research/volatility/implied.py`

结构：
1. Black-Scholes price + vega。
2. bisection（稳健但慢）。
3. newton（快但依赖 vega 与初值）。
4. hybrid（先二分粗定位，再牛顿精化）。

实践重点：
1. 明白“无解”并不罕见（价格越界、深度异常）。
2. 牛顿法必须处理 vega 过小退化。
3. 曲面插值不是“真模型”，是数据近似。

## 4.3 波动率动力学模型
文件：`research/volatility/models.py`

实现包括：
1. EWMA
2. GARCH(1,1)
3. HAR-RV
4. 粗糙波动率签名估计（roughness/Hurst 近似）

你要关注：
1. 参数约束（如 GARCH 平稳性 alpha+beta<1）。
2. 参数估计失败时的回退逻辑。
3. 模型输出如何喂给策略（不是孤立建模）。

## 4.4 风险数学：VaR/CVaR/压力测试
文件：`research/risk/var.py`

实现三种 VaR：
1. Parametric
2. Historical
3. Monte Carlo（支持 Greeks 近似）

关键实践点：
1. 输入资产权重与收益序列对齐。
2. 协方差矩阵正定性处理。
3. 压力场景与常规 VaR 的互补关系。

## 4.5 组合 Greeks 聚合（跨币种）
文件：`research/risk/greeks.py`

该模块不仅算 Greeks，还做**跨币种聚合与 FX 转换**，这是实盘里最容易犯错的部分之一。

你应重点验证：
1. inverse vs non-inverse 的量纲转换。
2. Delta/Gamma 转 USD notional 的换算路径。
3. 组合级求和是否符合经济意义（同币种先聚合）。

---

## 5. 算法理论与实践（策略与决策系统）

## 5.1 波动率状态检测：HMM 与低延迟降级
标准版：`research/signals/regime_detector.py`  
低延迟版：`research/signals/fast_regime_detector.py`

算法思想：
1. 用收益率与 realized vol 特征做状态分类（LOW/MEDIUM/HIGH）。
2. 用状态驱动 spread multiplier。
3. 在 fast 版中引入异步训练+超时降级（阈值分类兜底）。

工程-算法耦合点：
1. 训练不能阻塞 quote 热路径。
2. 模型收敛 warning 需要“降噪但不掩盖异常”。
3. 统计监控（fallback ratio）比单次精度更重要。

## 5.2 自适应 Delta 对冲
文件：`research/hedging/adaptive_delta.py`

核心机制：
1. 基础对冲间隔 + 价格跌幅触发加速。
2. Gamma 高时调整频率与步长。
3. 通过 `HedgeDecision` 输出可解释决策理由与紧急度。

重点不是“是否对冲”，而是“什么时候对冲 + 对冲多少 + 代价多少”。

## 5.3 综合做市策略（主流程）
标准版：`strategies/market_making/integrated_strategy.py`  
快速版：`strategies/market_making/fast_integrated_strategy.py`

标准版主要流程：
1. 更新组合状态和 PnL。
2. circuit breaker 判定可交易性。
3. 更新 regime。
4. 运行 adaptive hedger。
5. 计算 reservation price 与 spread。
6. 应用库存约束生成 quote。

快速版重点：
1. fast regime detector
2. Greeks 缓存
3. 延迟统计
4. 可配置功能开关

## 5.4 套利算法族
目录：`strategies/arbitrage/`

包含：
1. `cross_exchange.py`：跨所价差套利（含费用与时效过滤）。
2. `basis.py`：期现基差套利（fair value + carry）。
3. `conversion.py`：put-call parity 偏离套利。
4. `option_box.py`：box spread 隐含利率/无套利边界。

学习建议：
1. 不要只看信号，必须连同“交易成本 + 容量 + 执行时延”一起评估。
2. 逐个策略构造反例（有价差但无利润）。

## 5.5 回测算法与反前视偏差
文件：`research/backtest/engine.py`

核心优点：
1. 事件驱动回放。
2. fill simulator 考虑延迟、部分成交、逆向选择。
3. 将观察与执行分离，减少 look-ahead bias。

这是你从“策略脚本”迈向“可审查研究系统”的关键。

## 5.6 策略竞技场与指标体系
文件：`research/backtest/arena.py`

提供：
1. 多策略同数据公平对比。
2. 收益、风险、交易行为、做市特有指标综合评分。
3. 可视化比较。

建议把它当作**策略评审标准化入口**。

---

## 6. 工程理论与实践（把模型变成系统）

## 6.1 类型系统与验证前置
文件：`core/types.py`, `core/validation/schemas.py`, `core/validation/validators.py`

工程思想：
1. 先类型后逻辑：`MarketState/OrderBook/Greeks/Position` 统一语义。
2. 数据入口即验证，失败尽早暴露。
3. 校验逻辑覆盖“数值范围 + 结构完整 + 领域约束”。

实践中这会显著减少“脏数据把策略带偏”的概率。

## 6.2 数据工程：多层缓存架构

### 6.2.1 Parquet 层（历史真源）
文件：`data/cache.py`

特点：
1. 按日期切分，便于范围读写。
2. `put_range` 支持跨天拆分。
3. 读取失败容错（损坏文件返回 None 并告警）。

### 6.2.2 DuckDB 层（分析加速）
文件：`data/duckdb_cache.py`

特点：
1. SQL 直接查 Parquet。
2. 可构建 tick/trade view。
3. resample 到 OHLCV。
4. 含参数校验（标识符/timeframe）防 SQL 注入与语法错误。

### 6.2.3 Redis 层（实时热点）
文件：`data/redis_cache.py`

特点：
1. TTL 缓存 Greeks/IV/orderbook/ticker。
2. Pub/Sub 实时广播。
3. Lua 原子限流脚本。
4. 支持批量读取与统计。

### 6.2.4 统一管理
文件：`data/integrated_manager.py`

把 Parquet + DuckDB + Redis 封装成一个接口，避免策略层知道底层细节。

## 6.3 交易所接入与流处理
下载器：`data/downloaders/deribit.py`, `data/downloaders/okx.py`  
流处理：`data/streaming.py`

关键工程点：
1. 异步连接管理与自动重连。
2. 订阅回调统一路由。
3. 消息队列背压，避免高峰爆内存。
4. 对过期/异常消息做时效过滤。

## 6.4 运行时可靠性：健康检查与服务生命周期
文件：`core/health_server.py`, `execution/service_runner.py`

实现了：
1. `/health` 存活探针
2. `/ready` 就绪探针
3. SIGINT/SIGTERM 优雅停机
4. 容器入口统一运行模板

## 6.5 质量工程：测试、类型、CI、性能门禁

### 6.5.1 测试层
- 单元/集成/性能测试集中在 `tests/`。
- 最近一次本地全量回归结果：`635 passed`（约 10 分钟量级）。

### 6.5.2 CI（关键）
文件：`.github/workflows/ci.yml`

当前门禁包括：
1. ruff
2. black --check
3. mypy（增量严格模块）
4. pytest + 覆盖率阈值（`--cov-fail-under=75`）
5. 性能回归脚本（轻量 benchmark 子集）

### 6.5.3 你要形成的习惯
1. 先有失败测试，再写修复。
2. 先局部验证，再全量验证。
3. 修改数学逻辑时必须附带数值回归。

## 6.6 部署与运维
参考：`deployment/DEPLOYMENT.md` 与 `deployment/` 下配置。

核心理念：
1. 交易引擎与基础设施解耦（Redis/Postgres/Prometheus/Grafana）。
2. 健康检查、日志、监控、回滚策略先于“上线速度”。
3. 风险组件（熔断器）必须可观测、可审计。

---

## 7. 从零到一的实操学习路径（建议 6 周）

## 第 1 周：建立系统感
1. 通读 `README.md` + 本文档 + `docs/architecture.md`。
2. 跑通测试与最小示例。
3. 画出你自己的模块依赖图。

## 第 2 周：币本位定价与 Greeks
1. 精读 `research/pricing/inverse_options.py`。
2. 手算 1 组 price/greeks 并与代码对齐。
3. 跑 `tests/test_pricing_inverse.py` 与相关验证脚本。

## 第 3 周：波动率与风控数学
1. 实验 5 种历史波动率估计器。
2. 运行 IV 求解与曲面插值。
3. 跑 VaR 三种方法并比较稳定性。

## 第 4 周：策略与回测
1. 对照读 `integrated_strategy` 与 `fast_integrated_strategy`。
2. 自定义一个库存参数并回测对比。
3. 在 `arena.py` 做多策略评分。

## 第 5 周：数据工程与实时层
1. 跑一条“下载 -> 缓存 -> DuckDB 查询 -> Redis 热缓存”的完整链路。
2. 验证 streaming 回调与背压行为。
3. 做一次错误注入（断网/脏数据）并观察系统反应。

## 第 6 周：工程化闭环
1. 按 CI 流程本地完整执行。
2. 写一个小功能（例如新增一个风险阈值）并补测试。
3. 做一次“从需求到 PR”的完整演练。

---

## 8. 面向实战的阅读顺序（按文件）

### 8.1 必读（第一优先级）
1. `core/types.py`
2. `research/pricing/inverse_options.py`
3. `research/risk/greeks.py`
4. `research/risk/circuit_breaker.py`
5. `research/signals/regime_detector.py`
6. `strategies/market_making/integrated_strategy.py`
7. `research/backtest/engine.py`

### 8.2 次优先级（工程扩展）
1. `data/cache.py`
2. `data/duckdb_cache.py`
3. `data/redis_cache.py`
4. `data/streaming.py`
5. `data/downloaders/deribit.py`
6. `data/downloaders/okx.py`
7. `.github/workflows/ci.yml`

### 8.3 深入验证材料
1. `tests/test_priority_fixes.py`
2. `tests/test_fast_integrated_strategy.py`
3. `tests/performance/latency_benchmark.py`
4. `validation_scripts/*.py`

---

## 9. 常见误区（你要主动避免）

1. 把 inverse 期权当线性产品处理。
2. 只看 Sharpe 不看尾部风险与执行成本。
3. 只看离线回测，不看实时缓存/延迟/数据新鲜度。
4. 只做功能，不做回归测试与性能门禁。
5. 把 warning 当噪音忽略，而不是分类治理（可行动 vs 不可行动）。

---

## 10. 建议你立刻执行的命令

```bash
cd "<项目根目录>/corp"

# 1) 全量回归（先建立“系统可信”）
./venv/bin/pytest tests/ -q

# 2) 关键数学/策略测试
./venv/bin/pytest -q \
  tests/test_pricing_inverse.py \
  tests/test_pricing_boundary.py \
  tests/test_priority_fixes.py \
  tests/test_fast_integrated_strategy.py

# 3) 性能回归子集
./venv/bin/python tests/performance/latency_benchmark.py \
  --iterations 150 \
  --benchmarks greeks_calculation,circuit_breaker,adaptive_hedger \
  --fail-on-target-miss
```

---

## 11. 你下一步如何“真正吃透”这个项目

如果你希望我继续，我建议按以下节奏进行：
1. 我给你做“源码导读版”第二册：逐文件函数级注解（按调用链）。
2. 再做“数学推导版”第三册：从 measure change 到 inverse Greeks 全推导。
3. 再做“工程实战版”第四册：新增一个完整子策略并通过全门禁。

这三册做完，你基本就不是“会用项目”，而是“能主导演进项目”。

---

## 12. 数学理论深度补编（完整版）

本章补齐第一册此前相对简略的数学部分，重点覆盖：
1. 币本位量纲与无套利边界。
2. inverse 定价公式来源（含测度与变量变换直觉）。
3. inverse Greeks 的符号与数量级分析。
4. 风险度量（VaR/CVaR/回撤）与组合聚合数学。
5. 数值分析（收敛、稳定性、误差传播）。

### 12.1 量纲系统：先统一单位再谈公式

很多“看起来正确”的推导错误，本质是量纲不一致。建议先固定单位体系：
1. 标的价格：`S`，单位 USD/BTC。
2. inverse 期权价格：`V_inv`，单位 BTC。
3. 仓位大小：`q`，按项目语义常近似视为合约数量。
4. inverse PnL：单位 BTC（如需 USD 报告再乘 `S` 或采用更严谨换算）。

在 `research/pricing/inverse_options.py` 中，`calculate_price` 返回的就是币计价结果；这与线性（USD 计价）期权核心不同。

### 12.2 inverse payoff 与无套利边界

项目采用的到期 payoff（币计价）：
1. Call：`max(0, 1/K - 1/S_T)`。
2. Put：`max(0, 1/S_T - 1/K)`。

由此可直接得到价格边界：
1. `0 <= C_inv <= exp(-rT)/K`。
2. `0 <= P_inv <= 1/S`（在常见参数区间下可作为上界参考）。

这也是 `calculate_implied_volatility` 里先做 price 合理性判断的数学来源：若市场价超出边界，IV 问题通常无解或不稳定。

### 12.3 币本位 PnL 非线性：凸凹性与风险含义

`core/types.py:Position.unrealized_pnl(inverse=True)` 和 `research/pricing/inverse_options.py:calculate_pnl` 均使用：
\[
\mathrm{PnL}_{inv}=q\left(\frac{1}{S_0}-\frac{1}{S_t}\right)
\]

对多头 `q>0`：
\[
\frac{\partial \mathrm{PnL}}{\partial S_t} = \frac{q}{S_t^2}>0,\quad
\frac{\partial^2 \mathrm{PnL}}{\partial S_t^2} = -\frac{2q}{S_t^3}<0
\]

结论：
1. 多头在价格上升时盈利增加，但边际收益递减。
2. 价格下跌时亏损加速。
3. 这解释了为何 inventory 控制与熔断阈值必须比线性合约更保守。

### 12.4 变量变换直觉：为什么会出现 K/S 而非 S/K

定义 `Y = 1/S`，则 inverse payoff 变成对 `Y` 的线性形式。直觉上：
1. 线性期权在 `S` 空间表达。
2. inverse 期权在 `1/S` 空间更自然。

因此 `d1,d2` 结构会从 `ln(S/K)` 变成 `ln(K/S)`。项目中的 `_calculate_d1_d2` 正是这一点：
\[
d_1=\frac{\ln(K/S)+(r+\frac12\sigma^2)T}{\sigma\sqrt{T}},\quad d_2=d_1-\sigma\sqrt{T}
\]

这不是“写反了”，而是 payoff 空间变化的必然结果。

### 12.5 inverse 价格公式的逻辑分解

项目实现：
1. `C_inv = exp(-rT)*(1/K)N(-d2) - (1/S)N(-d1)`。
2. `P_inv = (1/S)N(d1) - exp(-rT)*(1/K)N(d2)`。

可从两部分理解：
1. 贴现行权项：`exp(-rT)/K`。
2. 标的倒数项：`1/S`。

这对应普通 BS 里“贴现 strike 项”和“spot 项”的角色映射，只是坐标换到 inverse 空间。

### 12.6 put-call parity（inverse）严谨版

项目函数 `inverse_option_parity(...)` 检验：
\[
C_{inv}-P_{inv}=\frac{e^{-rT}}{K}-\frac{1}{S}
\]

这是实盘里极其重要的“完整性约束”：
1. 用于发现报价数据异常。
2. 用于套利策略前置筛选（过滤伪信号）。
3. 用于验证模型实现没有量纲错误。

### 12.7 inverse Greeks 深入：不仅是“换个公式”

项目在 `_calculate_greeks_from_d` 中显式实现 Delta/Gamma/Theta/Vega/Rho。

关键注意点：
1. inverse 下 Call/Put 的 Gamma 不再天然同形。
2. Vega 存在 `VEGA_SCALING`（每 1% vol 变化），与牛顿法导数单位必须一致。
3. Theta 使用 `THETA_DAYS_PER_YEAR=365`，是“日衰减”口径。

如果把 Vega 缩放忽略，Newton IV 更新步长会系统性失真，表现为：
1. 收敛过慢。
2. 震荡。
3. 跳到边界（`sigma_low/sigma_high`）。

### 12.8 隐含波动率求解：存在性、唯一性与数值退化

设 `f(σ)=ModelPrice(σ)-MarketPrice`。常见条件下：
1. `f` 对 `σ` 单调（Vega 正）则根唯一。
2. 市场价超边界则无根。

项目采取“牛顿 + 二分回退”的混合策略：
1. 先牛顿快速逼近。
2. 遇 `|vega|` 极小或异常时，切二分保守收敛。

这在高波动、短期限、深度实虚值区域尤其重要。

### 12.9 波动率估计器：偏差-方差权衡

`research/volatility/historical.py` 给出多个估计器，可按信息集理解：
1. close-to-close：实现简单，忽略盘中范围信息。
2. Parkinson：用 high-low，提高效率但怕跳空。
3. Garman-Klass：引入 open/close，降低噪声。
4. Rogers-Satchell：允许漂移，稳健于趋势。
5. Yang-Zhang：综合夜盘跳空和盘中波动，常更稳健。

数学上是典型的估计器族比较：
1. 信息利用越充分，理论方差越低。
2. 模型假设错配时，偏差可能更大。

### 12.10 波动率模型：平稳性与可识别性

`research/volatility/models.py` 的核心数学约束：
1. EWMA：`lambda` 越大记忆越长，响应越慢。
2. GARCH(1,1)：需满足 `alpha + beta < 1` 保证协方差平稳。
3. HAR-RV：通过多时间尺度线性叠加近似长记忆。

很多“回测好看”的模型，失败点不在拟合，而在：
1. 参数不可识别。
2. 外样本 regime 切换后不稳定。
3. 对异常值过敏。

### 12.11 风险数学：VaR/CVaR/压力测试关系

在 `research/risk/var.py` 中：
1. Parametric VaR：假设分布（常正态）+ 协方差。
2. Historical VaR：经验分位数。
3. Monte Carlo VaR：路径模拟，可接 Greeks 非线性。

CVaR（Expected Shortfall）是 VaR 尾部条件均值，更适合作为“灾难损失”度量。

工程建议：
1. 交易前门禁可用 VaR 快速筛查。
2. 日内风险审计用 CVaR + 压力场景并行。
3. 压力测试不替代 VaR，而是补足“模型外事件”。

### 12.12 组合 Greeks 聚合与跨币种换算

`research/risk/greeks.py:analyze_portfolio` 的难点不是求和，而是换算。

核心原则：
1. 同币种先聚合。
2. 跨币种要先统一到同一风险计量单位（如 USD 口径）。
3. inverse 与 linear 的 Delta/Gamma 维度不同，换算路径不同。

若忽略量纲，最常见错误是：
1. 把 BTC Delta 和 ETH Delta 直接相加。
2. 把 inverse Delta 当无量纲处理。

### 12.13 回撤数学与风险解释

`research/risk/circuit_breaker.py:calculate_drawdown` 采用运行峰值定义：
\[
DD_t=\frac{P_t-\max_{u\le t}P_u}{|\max_{u\le t}P_u|_\epsilon}
\]

其中分母用安全下界避免除零，这是一种数值稳健化技巧。

解释上要分清：
1. 回撤是路径依赖风险，不是瞬时波动。
2. 同样波动率下，不同路径可有完全不同最大回撤。

### 12.14 数值稳定性检查清单（建议固定执行）

每次改数学逻辑前后，建议逐项检查：
1. 极限点：`T->0`、`sigma->0`、`S->0+`、`S->inf`。
2. 单调性：价格对 `sigma`、对 `S` 的符号是否合理。
3. Parity：call-put 偏差是否在容差内。
4. IV 收敛率：失败样本比例是否变化。
5. Greeks 量纲：是否仍与下游风险模块兼容。

### 12.15 数学习题（基础 + 进阶 + 工程）

说明：
1. 建议先独立作答，再看 12.16 标准解答。
2. 题目都可映射到项目代码，避免“只会纸面推导”。

#### A. 基础题

1. 设 `q=10`，`S_entry=50000`，`S_exit=55000`，按 inverse PnL 公式计算 PnL（单位 BTC）。

2. 对函数
\[
f(S)=q\left(\frac{1}{S_0}-\frac{1}{S}\right),\ q>0
\]
求一阶、二阶导并解释其经济含义。

3. 写出 inverse parity 公式，并说明左边与右边各代表什么。

4. 说明为什么 inverse `d1` 里是 `ln(K/S)` 而不是 `ln(S/K)`。

5. 已知 `T->0` 时，inverse call 价格应退化到什么表达式？

#### B. 进阶题

6. 证明（或给出严谨说明）：
\[
0 \le C_{inv}\le \frac{e^{-rT}}{K}
\]

7. 当 market price 超出理论边界时，解释 IV 求解为什么会失败，并指出在代码中应在哪一步阻断。

8. 设 `vega_reported` 是“每 1% vol 变化”的 vega，推导 Newton 更新里应使用的 `vega_per_unit`。

9. 给定两币种（BTC、ETH）组合 Greeks，说明为什么不能直接把 Delta 相加；写出正确的聚合原则。

10. 解释 `calculate_drawdown` 中分母要做安全下界处理（`epsilon`）的数学与工程原因。

#### C. 工程化题

11. 设计一个“数学回归最小套件”（不少于 5 项检查），用于修改 `inverse_options.py` 后的自动验证。

12. 设计一组参数扫描实验，验证 `sigma` 对 inverse 价格与 Greeks 的单调性和数量级是否合理。

13. 给出一个你认为“容易被量纲错误污染”的模块点，并说明如何在 CI 中加防线。

14. 编写一个“无套利哨兵”思路：实时监控 parity 偏差并分类告警（数据问题/模型问题/市场瞬时偏离）。

### 12.16 数学习题标准解答（参考）

#### A. 基础题解答

1. 题 1：
\[
\mathrm{PnL}=10\left(\frac{1}{50000}-\frac{1}{55000}\right)
=10(2.0\times10^{-5}-1.81818\times10^{-5})
\approx 1.8182\times10^{-5}\ \mathrm{BTC}
\]

2. 题 2：
\[
f'(S)=\frac{q}{S^2}>0,\quad
f''(S)=-\frac{2q}{S^3}<0
\]
解释：
1. 价格上升时多头 inverse PnL 增加。
2. 但增速递减（凹函数），下跌时亏损“加速度”更明显。

3. 题 3：
\[
C_{inv}-P_{inv}=\frac{e^{-rT}}{K}-\frac{1}{S}
\]
左边是同 strike/expiry 的 call-put 价差，右边是 inverse 语义下的“贴现行权倒数项 - 标的倒数项”。

4. 题 4：
因为 payoff 写在 `1/S` 空间，变量变换 `Y=1/S` 后，log moneyness 自然转为 `ln(K/S)` 结构。

5. 题 5：
\[
\lim_{T\to0} C_{inv}= \max\left(0,\frac{1}{K}-\frac{1}{S}\right)
\]
与 `calculate_price` 的到期边界实现一致。

#### B. 进阶题解答

6. 题 6（思路）：
`C_inv` 由两个非负项差构成，且 `N(-d2)<=1`、`N(-d1)>=0`，于是：
\[
C_{inv} \le e^{-rT}\frac{1}{K}
\]
又期权价格非负（数值实现里也有 `max(0, price)`）。

7. 题 7：
若市场价低于下界或高于上界，则不存在使 `ModelPrice(σ)=MarketPrice` 的 `σ`。代码中应在 IV 入口先做边界检查（`calculate_implied_volatility` 已这么做）。

8. 题 8：
若 `vega_reported = dV/d(1%vol)`，则
\[
\frac{dV}{d\sigma} = \frac{vega\_{reported}}{0.01}=100\cdot vega\_{reported}
\]
Newton 步长要用 `dV/dσ` 而不是报告口径 vega。

9. 题 9：
BTC Delta 与 ETH Delta 是不同风险单位，直接相加没有经济意义。应：
1. 同币种先聚合。
2. 再按 FX/spot 规则转换到统一口径（如 USD notional）后再跨币种聚合。

10. 题 10：
当历史峰值接近 0 时，分母会放大噪声甚至除零。加 `epsilon` 可保证：
1. 数值稳定。
2. 风险指标连续可计算。

#### C. 工程化题解答（示例）

11. 题 11（一个可执行模板）：
1. 价格非负检查（随机参数）。
2. 到期边界检查（`T≈0`）。
3. parity 偏差容差检查。
4. IV 反解闭环检查（price->iv->price）。
5. 极值稳定性检查（`sigma`、`S` 端点）。

12. 题 12（实验方案）：
1. 固定 `K,T,r`，扫描 `sigma`。
2. 记录 `price, delta, gamma, vega`。
3. 检查单调方向和曲线平滑性。
4. 对比相邻点差分，排查异常跳变。

13. 题 13（示例答案）：
模块：`research/risk/greeks.py` 跨币种聚合。
CI 防线：
1. 加入“同币种/跨币种”对照测试。
2. 强制验证聚合后单位与数值范围。

14. 题 14（哨兵思路）：
1. 实时计算 `parity_gap = lhs-rhs`。
2. 分档阈值（info/warn/critical）。
3. 若多合约同步偏离优先判数据源问题。
4. 单合约持续偏离再判模型/市场微结构问题。
5. 输出到告警系统并带上下文快照。

---

## 13. 算法理论深度补编（完整版）

本章补齐第一册算法理论深度，目标是把“功能流程”提升到“可证明、可分析、可优化”的算法视角。

### 13.1 做市问题的随机控制形式

把做市写成受约束控制问题：
\[
\max_{\pi}\mathbb{E}\left[\sum_t R_t\right],\quad
R_t=R_t^{spread}-\lambda_q q_t^2-\lambda_{tail}\mathrm{TailRisk}_t-\lambda_c C_t
\]
约束包括：
1. 库存约束 `|q_t| <= Q_t`。
2. 熔断约束（状态机）。
3. 延迟预算约束（工程可行性）。

这对应 `integrated_strategy.quote` 里“先风险门、再控制律、再裁剪动作”的顺序。

### 13.2 Avellaneda-Stoikov：从 HJB 到可实现策略

AS 的关键近似产物：
1. Reservation price：`r = s - q*gamma*sigma^2*(T-t)`。
2. Optimal spread：库存风险项 + 到达强度项。

在工程实现中，项目保留了核心结构并加入：
1. 库存偏移裁剪（防极端报价）。
2. regime 与 circuit 乘子耦合。

这是一种“模型驱动 + 工程稳健化”的典型方案。

### 13.3 集成策略是“分层控制器”

`IntegratedMarketMakingStrategy.quote` 可视为四层控制：
1. 风险可行域层：`check_risk_limits` + `can_trade`。
2. 状态估计层：regime detector + returns 更新。
3. 对冲控制层：adaptive hedger 决策。
4. 报价执行层：reservation + spread + size。

理论价值：
1. 每层可独立分析和替换。
2. 出故障时更易定位根因。

### 13.4 Regime 检测：HMM 的统计与计算

标准版 `VolatilityRegimeDetector` 的核心算法：
1. 特征提取（return + realized vol 多窗口）。
2. HMM 训练（EM）。
3. 后验概率推断与状态映射。

复杂度直觉：
1. 训练复杂度随样本量和状态数上升。
2. 在线高频路径中，训练必须限频，否则会阻塞。

fast 版通过异步训练 + 超时降级把这类阻塞问题转成可控近似误差。

### 13.5 Fast Regime Detector：anytime 算法思想

`FastVolatilityRegimeDetector` 可视为 anytime 机制：
1. 先用阈值分类给出快速可用答案。
2. 若 HMM 在超时内返回，用更高质量结果覆盖。
3. 否则保留阈值结果。

这个结构在实时系统里很关键：
1. 保证上界延迟。
2. 提供可量化的降级统计（`fallback_ratio`）。

### 13.6 自适应对冲：触发器融合与动作裁剪

`AdaptiveDeltaHedger.should_hedge` 实际是多触发器融合：
1. 时间触发。
2. Delta 偏离触发。
3. 紧急度触发（跌幅/Gamma）。

然后用 `_calculate_hedge_size` 做动作限幅：
1. 最小对冲量避免噪声频繁交易。
2. 最大对冲比例避免一次性过度冲击。

这是典型“触发逻辑 + 控制器饱和”的工程控制结构。

### 13.7 熔断状态机：安全自动机模型

`CircuitBreaker` 本质是一个有序状态自动机：
1. `NORMAL -> WARNING -> RESTRICTED -> HALTED`（风险升级）。
2. 恢复时逐级回落（含冷却期）。

数学上它实现的是“可行动作集合”的动态收缩：
1. 风险上升时，可行动作集变小。
2. 直至只允许对冲/平仓或完全停止。

这比单纯损失罚项更可靠，因为是硬约束。

### 13.8 回测引擎：事件驱动与反前视机制

`research/backtest/engine.py:run` 的关键算法设计：
1. 先处理上一周期 quote 的潜在成交。
2. 再根据当前（或滞后）观测生成下一周期 quote。

这相当于把“观测时刻”和“执行时刻”显式分离，降低 look-ahead bias。

### 13.9 Fill 模拟：微观结构近似

引擎中的 fill 机制包含：
1. 延迟模拟。
2. 队列位置近似。
3. 部分成交概率。
4. 滑点与逆向选择。

这些并非“真实撮合引擎”，但比简单 mid-price fill 更接近实盘统计特性。

### 13.10 策略竞技场：公平比较与统计检验

`StrategyArena` 的价值：
1. 同数据、同回测框架比较，减少评估偏差。
2. 除收益外同时看风险与交易行为。
3. 提供 pairwise 统计检验与多重比较修正。

建议长期使用：
1. 新策略必须通过 arena 基准比较后再进入候选集。

### 13.11 算法复杂度与热路径预算

高频系统里，最优算法不等于最好算法，必须看时间预算：
1. `quote` 热路径目标常在毫秒级。
2. 训练类任务必须异步或离线。
3. 缓存命中策略可把平均延迟显著下拉。

项目中 fast 版与标准版并存，体现了“精度-延迟双轨制”。

### 13.12 参数标定算法：约束优化而非单指标最大化

推荐形式：
\[
\max_{\theta}\ \text{Sharpe}(\theta) + w_1\text{PnL}(\theta) - w_2\text{Turnover}(\theta)
\]
约束：
1. `MaxDD(theta) <= d_max`。
2. `CVaR(theta) <= c_max`。
3. `LatencyP95(theta) <= t_max`。

这是把策略性能与工程可运行性放在同一优化问题里。

### 13.13 在线自适应：漂移检测与再标定触发

建议监控以下漂移信号：
1. fill-rate 漂移。
2. adverse selection 成本漂移。
3. regime 分布漂移。
4. fallback ratio 漂移。

触发后流程：
1. 小规模参数重估。
2. 回测与压力回归。
3. 灰度发布。
4. 监控对比后再全量。

### 13.14 算法失败模式（必须提前预案）

常见失败模式：
1. HMM 训练不收敛导致状态抖动。
2. 对冲过度导致交易成本吞噬收益。
3. 风控阈值过紧导致长期“几乎不交易”。
4. 风控阈值过松导致尾部损失不可接受。
5. 缓存参数不当导致“快但错”或“慢且不稳”。

建议每类失败模式都准备：
1. 监测信号。
2. 自动降级动作。
3. 人工介入 runbook。

### 13.15 数学-算法-工程三线闭环

本章最后给一个统一闭环框架：
1. 数学层：给出目标、约束、边界与量纲。
2. 算法层：给出状态估计、控制器、近似与复杂度。
3. 工程层：给出热路径预算、监控、回滚、验证。

只有三线都闭环，策略才具备长期可运营性。

### 13.16 算法习题（基础 + 进阶 + 系统）

说明：
1. 先按“算法定义 -> 复杂度 -> 工程约束”顺序作答。
2. 每题都应尽量映射到具体函数。

#### A. 基础题

1. 画出 `IntegratedMarketMakingStrategy.quote` 的 10 步主调用链，并标出“硬约束步骤”。

2. 为什么 `check_risk_limits` 必须在报价计算前执行，而不是后置处罚？

3. `FastVolatilityRegimeDetector` 里阈值分类 + HMM 结果覆盖的逻辑属于哪类实时算法思想？

4. `AdaptiveDeltaHedger` 的三个主要触发器是什么？它们是“与/或”关系？

5. 回测里把“观察”和“执行”分离可以减少哪类偏差？请给出一个反例场景。

#### B. 进阶题

6. 给出一个简化目标函数，包含 spread 收益、库存惩罚、交易成本，并说明每项对应的可观测指标。

7. 分析 `max(regime_mult, circuit_mult)` 与 `regime_mult * circuit_mult` 两种融合规则的差异与适用场景。

8. 解释为什么 HMM 训练要异步化；若同步训练可能导致什么生产事故链？

9. 设计一个 `fallback_ratio` 的控制阈值策略，并说明阈值过高/过低的副作用。

10. 说明 fill simulator 中“延迟 + 滑点 + 部分成交 + 逆向选择”四者缺一不可的原因。

#### C. 系统题

11. 设计一个“参数重估触发器”算法，输入是 7 天滚动指标，输出是“是否重估 + 重估范围”。

12. 设计一个策略灰度发布算法（10%->50%->100%），给出每阶段的放量条件与回滚条件。

13. 给出一个自动降级策略：当 `P95 latency` 超阈值 5 分钟时，如何逐级关闭非核心功能。

14. 写出你认为最关键的 5 个在线指标，并给出它们与策略质量的因果链解释。

### 13.17 算法习题标准解答（参考）

#### A. 基础题解答

1. 题 1（主链可写为）：
1. 更新组合状态。
2. 风险检查。
3. 可交易性判定（硬约束）。
4. 更新收益/状态检测。
5. 对冲决策。
6. 计算 spread multiplier。
7. 计算 reservation price。
8. 计算可执行 quote size。
9. 记录指标。
10. 返回 quote。

2. 题 2：
后置处罚无法阻止“违规动作已经发出”。风险控制应是动作可行域约束，不是结果惩罚。

3. 题 3：
属于 anytime/降级可用算法：先给快速可用解，再尝试高质量解覆盖。

4. 题 4：
触发器：
1. 时间触发。
2. Delta 偏离触发。
3. 紧急度触发。
判定上主要是“或”关系（任一满足可触发）。

5. 题 5：
减少 look-ahead bias。反例：用 `t+1` 的价格信息决定 `t` 的报价，会虚高策略表现。

#### B. 进阶题解答

6. 题 6（示例）：
\[
J=\mathbb{E}[R^{spread}] - \lambda_q\mathbb{E}[q_t^2] - \lambda_c\mathbb{E}[turnover]
\]
指标映射：
1. `R^{spread}` -> spread capture。
2. `q_t^2` -> inventory variance / max abs inventory。
3. `turnover` -> traded notional / hedge count。

7. 题 7：
`max` 融合更保守，强调“以更危险风险源为准”；乘法融合对多风险叠加更敏感，但需 clip 防极端放大。

8. 题 8：
同步训练会占用热路径 CPU，导致：
1. 报价延迟上升。
2. 风控判定滞后。
3. 可能触发连锁降级或误熔断。

9. 题 9（示例）：
1. 设警戒阈值 5%，危险阈值 20%。
2. 连续超过危险阈值 3 个窗口触发策略降级。
阈值过高：问题长期隐藏；过低：频繁误降级。

10. 题 10：
缺任一项都会系统性高估策略质量：
1. 无延迟：高估可执行性。
2. 无滑点：高估成交价。
3. 无部分成交：高估成交量。
4. 无逆向选择：低估信息劣势损失。

#### C. 系统题解答（示例框架）

11. 题 11（触发器框架）：
输入：7 天 `fill_rate`、`adverse_cost`、`drawdown`、`fallback_ratio`。
规则：
1. 任一关键指标偏离基线 >2σ 且持续 3 天 -> 触发重估。
2. 若风险类指标恶化优先重估风控参数，否则重估策略参数。

12. 题 12（灰度算法）：
1. 10% 阶段：30 分钟内 SLO 全达标 -> 升 50%。
2. 50% 阶段：60 分钟内无 critical 告警且 PnL 偏离可接受 -> 升 100%。
3. 任一阶段若 `latency`/`risk` 超阈值持续 N 分钟 -> 立即回滚。

13. 题 13（降级序列示例）：
1. 关闭 HMM 预测，仅阈值分类。
2. 提高缓存 TTL，减少计算开销。
3. 暂停非关键特征提取。
4. 必要时扩大价差或降频报价。
5. 超过二级阈值进入保护模式（仅风险最小动作）。

14. 题 14（五个关键指标示例）：
1. `quote_latency_p95`：直接决定执行竞争力。
2. `fallback_ratio`：反映状态检测可用性退化。
3. `inventory_abs_mean`：反映库存风险暴露。
4. `circuit_state_ratio`：反映风险状态稳定性。
5. `adverse_selection_cost`：反映真实交易质量。
因果链：算法质量 -> 报价行为 -> 成交质量 -> 风险暴露 -> 组合收益分布。

---

## 14. 深度学习任务单（建议立即执行）

如果你要把第一册补编真正转化为能力，建议按下面任务做一遍：
1. 用 3 组参数手工复算 inverse price + Greeks，并与 `calculate_price_and_greeks` 对齐误差。
2. 对 `base_spread_bps` 和 `gamma` 做二维网格，画出 Sharpe / MaxDD 热力图。
3. 统计 `fast_regime_detector` 的 `fallback_ratio` 与策略收益/风险变化关系。
4. 在回测中故意提高 `inventory_limit`，观察熔断状态分布变化。
5. 写一页你自己的“量纲检查清单”，用于每次数学改动前后审核。

完成以上 5 项，你对本项目数学与算法理论就不再停留在“读懂”，而是进入“可推导、可验证、可调优”阶段。
