# CORP 项目深度学习手册（第三册）
> 主题：策略与风控联合推导（含公式证明 + 回测实验设计）
> 代码库：`<项目根目录>/corp`
> 目标：把“会调参数”升级为“能从目标函数到代码实现做一致性推导与验证”

---

## 0. 如何使用本册

本册是“联合推导册”，不是策略百科。建议按以下顺序阅读：
1. 先读第 1 章统一符号与量纲，避免后面混淆 USD、币、notional、Greeks 单位。
2. 再读第 2-4 章，看策略目标函数如何与风控约束耦合。
3. 再读第 5-6 章，把推导映射到项目函数调用链。
4. 最后执行第 7-9 章回测方案，验证理论是否真实提升收益风险比。

三条主线始终并行：
- 数学：目标函数、约束、极值、稳定性、证明。
- 算法：状态估计、控制律、近似、复杂度、退化路径。
- 工程：延迟预算、容错、缓存、线程安全、可观测性、可复现。

---

## 1. 统一符号、量纲与状态空间

### 1.1 核心符号

定义交易时刻离散为 \(t=0,1,2,\dots\)：

- \(S_t\)：标的中间价（USD/BTC）。
- \(q_t\)：库存（合约单位，正多负空）。
- \(c_t\)：现金或币余额（视模块而定）。
- \(\Delta_t,\Gamma_t,\Theta_t,\Vega_t\)：组合 Greeks。
- \(\sigma_t\)：即时波动率估计。
- \(z_t\in\{\text{LOW},\text{MEDIUM},\text{HIGH}\}\)：波动率 regime。
- \(x_t\in\{\text{NORMAL},\text{WARNING},\text{RESTRICTED},\text{HALTED}\}\)：熔断状态。

策略决策动作：
- 报价中心（reservation price）\(r_t\)
- 半价差 \(\delta_t\)
- 报价数量 \((v_t^{bid}, v_t^{ask})\)

最终报价：
\[
P_t^{bid} = r_t - \delta_t,\quad P_t^{ask}=r_t+\delta_t
\]

### 1.2 币本位量纲

项目中币本位（inverse）关键实现：
- `research/pricing/inverse_options.py`
- `core/types.py:Position.unrealized_pnl`

币本位未实现盈亏：
\[
\mathrm{PnL}_{inv}=q\left(\frac{1}{S_{entry}}-\frac{1}{S_t}\right)
\]

对多头 \(q>0\)：
\[
\frac{\partial \mathrm{PnL}_{inv}}{\partial S_t} = \frac{q}{S_t^2}>0,
\qquad
\frac{\partial^2 \mathrm{PnL}_{inv}}{\partial S_t^2} = -\frac{2q}{S_t^3}<0
\]

结论：多头 PnL 随价格上升单调增加但边际收益递减（凹函数）。

### 1.3 系统状态与控制问题

把系统写成受约束随机控制：
\[
\max_{\pi}~\mathbb{E}\left[\sum_{t=0}^{T-1} R_t\right]
\quad
\text{s.t.}
\quad x_t\neq \text{HALTED},\ |q_t|\le q_{max}(x_t)
\]

其中策略 \(\pi\) 输出 \((r_t,\delta_t,v_t^{bid},v_t^{ask})\)，
奖励可分解为：
\[
R_t = R_t^{spread} - \lambda_{inv}R_t^{inventory} - \lambda_{tail}R_t^{tail} - \lambda_{tc}R_t^{cost}
\]

---

## 2. 策略与风控的统一目标函数

### 2.1 做市收益项

理想化单步收益：
\[
R_t^{spread} \approx \frac{1}{2}\delta_t \cdot (N_t^{bid}+N_t^{ask})
\]

成交强度通常随离 mid 的距离衰减，可写成：
\[
\lambda^{bid}(\delta),~\lambda^{ask}(\delta) \propto e^{-k\delta}
\]
这正是 Avellaneda-Stoikov 结构中的核心假设。

### 2.2 库存风险项

常见二次惩罚：
\[
R_t^{inventory} = q_t^2 \sigma_t^2
\]
含义：高波动和大库存共同放大 inventory risk。

项目映射：
- `strategies/market_making/avellaneda_stoikov.py`
- `strategies/market_making/integrated_strategy.py::_calculate_reservation_price`

### 2.3 尾部风险项

可用 VaR/CVaR 近似：
\[
R_t^{tail} = \mathrm{CVaR}_{\alpha}(\Delta P_t)\quad\text{or}\quad \mathbb{I}(\mathrm{VaR}_{\alpha}>L)
\]

项目映射：
- `research/risk/var.py:VaRCalculator`
- `research/risk/circuit_breaker.py:check_var_limit`

### 2.4 熔断约束是“硬约束”

熔断不是“再罚一点”的软项，而是约束可行域：
- `HALTED`：不允许做市。
- `RESTRICTED`：只允许 hedging/liquidation。

项目映射：
- `research/risk/circuit_breaker.py:can_trade`
- `strategies/market_making/integrated_strategy.py:quote`

---

## 3. 核心公式推导与证明

### 3.1 命题 A：币本位 PnL 的上界与下界（多头）

设 \(q>0\)：
\[
f(S)=q\left(\frac{1}{S_0}-\frac{1}{S}\right)
\]

命题：
1. \(\lim_{S\to\infty} f(S)=q/S_0\)（收益上界）
2. \(\lim_{S\to0^+} f(S)=-\infty\)（亏损无下界）

证明：
- 当 \(S\to\infty\)，\(1/S\to0\)，代入得 \(q/S_0\)。
- 当 \(S\to0^+\)，\(1/S\to\infty\)，故 \(f(S)\to-\infty\)。
证毕。

这解释了为何币本位库存控制必须比线性合约更严格。

### 3.2 命题 B：AS 保留价对库存单调

AS 保留价：
\[
r_t = S_t - q_t\gamma\sigma^2(T-t)
\]

对 \(q_t\) 求导：
\[
\frac{\partial r_t}{\partial q_t}=-\gamma\sigma^2(T-t)<0
\]

结论：库存越多（更偏多），保留价越低，系统更倾向卖出降库存；反之亦然。

项目映射：
- `strategies/market_making/avellaneda_stoikov.py:quote`
- `strategies/market_making/integrated_strategy.py::_calculate_reservation_price`

### 3.3 命题 C：AS 最优半价差分解

代码中的半价差结构：
\[
\delta_t=\frac{1}{2}\gamma\sigma^2(T-t)+\frac{1}{\gamma}\ln\left(1+\frac{\gamma}{k}\right)
\]

第一项是库存风险补偿，第二项是执行风险补偿。

命题：当 \(\sigma\) 增大时，\(\delta_t\) 单调增大。

证明：
\[
\frac{\partial\delta_t}{\partial\sigma}=\gamma\sigma(T-t)\ge0
\]
证毕。

### 3.4 命题 D：`max` 融合风控乘子的保守性

标准 integrated 策略使用：
\[
m_t=\max(m_t^{regime}, m_t^{circuit})
\]
\[
\text{spread}_t = \text{base\_spread}\times m_t
\]

命题：若任一风险源恶化（其乘子增大），最终 spread 不减。

证明：
- `max` 对每个自变量单调不减。
- 与正基数相乘保持单调。
证毕。

项目映射：
- `strategies/market_making/integrated_strategy.py::_get_spread_multiplier`

### 3.5 命题 E：快策略乘法融合的可解释性

fast integrated 策略用乘法：
\[
m_t = m_t^{regime}\cdot m_t^{circuit},\quad m_t\in[0.5,3.0]~\text{(clip)}
\]

性质：
- 对任一乘子单调不减。
- clip 引入饱和区，防止极端扩大导致报价失真。

项目映射：
- `strategies/market_making/fast_integrated_strategy.py::_get_spread_multiplier`

### 3.6 命题 F：自适应对冲间隔对跌幅单调

设基础间隔 \(\tau_0\)，调整系数 \(a(d,\gamma)\in[1/M,2]\)：
\[
\tau_t = \tau_0\cdot a(d_t,\gamma_t)
\]
其中 \(d_t\) 为相对跌幅，跌得越多，\(a\) 越小。

命题：在阈值以上，\(d_t\) 增大时 \(\tau_t\) 不增。

证明思路：
- 配置中用分段线性放大跌幅因子并放入分母。
- 分母单调增 -> \(a\) 单调降 -> \(\tau_t\) 单调降。
证毕。

项目映射：
- `research/hedging/adaptive_delta.py::_calculate_adjusted_interval`

### 3.7 命题 G：熔断状态转移是“严重度有序”

定义严重度映射：
\[
\text{NORMAL}<\text{WARNING}<\text{RESTRICTED}<\text{HALTED}
\]

在 `check_risk_limits` 中，若 violation 严重度增加，状态不会朝更宽松方向跳转；恢复仅在冷却和无新违规后逐级下降。

项目映射：
- `research/risk/circuit_breaker.py:_determine_state`
- `research/risk/circuit_breaker.py:_can_recover`
- `research/risk/circuit_breaker.py:_get_recovery_state`

---

## 4. 算法联合设计：从状态估计到控制律

### 4.1 状态估计层

1. 波动率状态检测（regime）：
- 标准版：`research/signals/regime_detector.py`
- 快速版：`research/signals/fast_regime_detector.py`

2. Greeks 与组合风险：
- `research/risk/greeks.py`

3. 尾部风险：
- `research/risk/var.py`

输出统一抽象为：
\[
\hat{s}_t=(\hat\sigma_t,z_t,\Delta_t,\Gamma_t,\mathrm{VaR}_t,x_t)
\]

### 4.2 控制层（策略）

给定 \(\hat{s}_t\)，策略生成：
\[
\pi(\hat{s}_t)\to (r_t,\delta_t,v_t^{bid},v_t^{ask})
\]

策略族：
- 基线：`NaiveMarketMaker`
- 解析模型：`AvellanedaStoikov`
- 联合策略：`IntegratedMarketMakingStrategy`
- 低延迟联合策略：`FastIntegratedMarketMakingStrategy`
- 监督学习：`XGBoostSpreadStrategy`
- 强化学习：`PPOMarketMaker`

### 4.3 约束执行层（Risk Gate）

交易前风控门：
1. 组合状态更新 -> `PortfolioState`
2. `check_risk_limits`
3. `can_trade`
4. 若不可交易，输出零报价

这是“控制屏障函数”的工程等价实现。

### 4.4 复杂度与延迟预算

热路径大致复杂度：
- 报价核心：\(O(1)\)
- regime 更新：阈值法 \(O(1)\)，HMM 推理近似 \(O(K^2)\)（小常数）
- 熔断检查：\(O(n_{limits})\)

工程目标：把“理论最优”控制在可用延迟内，不牺牲稳定性。

---

## 5. 代码级联合调用链（函数级）

### 5.1 标准联合策略调用链

`IntegratedMarketMakingStrategy.quote` 的主链：

1. `_update_portfolio_state`
2. `circuit_breaker.check_risk_limits`
3. `circuit_breaker.can_trade`
4. `_calculate_return`
5. `regime_detector.update`
6. `hedger.should_hedge` / `hedger.execute_hedge`
7. `_get_spread_multiplier`
8. `_calculate_reservation_price`
9. `_calculate_quote_sizes`
10. 返回 `QuoteAction`

数学对应：
- 第 2-3 步是约束投影。
- 第 7-8 步是控制律参数化。
- 第 9 步是可行域截断。

### 5.2 快策略调用链

`FastIntegratedMarketMakingStrategy.quote` 的主链：

1. `_update_portfolio_state`（简化）
2. `check_risk_limits/can_trade`
3. `_calculate_return`
4. `fast_regime_detector.update`
5. Greeks 缓存 `_get_cached_greeks/_set_cached_greeks`
6. `hedger.should_hedge`
7. `_get_spread_multiplier`（乘法 + clip）
8. `_calculate_reservation_price`
9. `_calculate_quote_sizes`

算法权衡：
- 标准版偏“解释性/稳态质量”。
- fast 版偏“低延迟/高可用”。

### 5.3 回测引擎调用链

`BacktestEngine.run` 主链：

1. 初始化状态与随机种子
2. 循环事件：
- 更新 order book
- 用前一时刻 quote 模拟成交
- `_process_fill`
- `strategy.on_fill`
- 当前时刻观测生成下一时刻 quote
3. `_record_state`
4. `_compute_result`

关键点：
- 使用 lagged price 防止直接 look-ahead。
- fill simulator 引入延迟、滑点、部分成交概率。

### 5.4 竞技场评估调用链

`StrategyArena.run_tournament`：
1. 对每个策略运行 `BacktestEngine.run`
2. `_calculate_scorecard`
3. `_create_comparison_df`
4. 可选 `statistical_comparison`

这构成“统一评测容器”，保证横向比较公平。

---

## 6. 数学证明补充：策略-风控一致性

### 6.1 定理 1：风险门后动作可行性

定义可行动作集 \(\mathcal{A}(x_t)\)：
- `HALTED`：\(\mathcal{A}=\{\text{no quote}\}\)
- `RESTRICTED`：仅允许对冲/平仓相关动作
- 其他：全动作可用

定理：若动作由 `can_trade` 过滤后输出，则系统动作始终属于 \(\mathcal{A}(x_t)\)。

证明：
- `quote` 在交易前调用 `can_trade`。
- `False` 分支强制 bid/ask size 为 0。
- `True` 分支再经过库存上限截断。
故输出动作在可行域内。证毕。

### 6.2 定理 2：库存截断后的有界性

设基础 quote size 为 \(v\)，库存上限为 \(Q\)。
`_calculate_quote_sizes` 通过边界修正，使得下一步库存满足 \(|q_{t+1}|\le Q\)（忽略撮合超额和异步延迟）。

证明要点：
- 买侧若 `q+v>Q`，则 `bid_size=max(0,Q-q)`。
- 卖侧若 `q-v<-Q`，则 `ask_size=max(0,q+Q)`。
- 单步执行后库存不越界。
证毕。

### 6.3 定理 3：风险乘子单调保守

无论 `max` 还是乘法（正区间）融合，只要每个子乘子对风险代理变量单调不减，最终 spread 对风险代理也单调不减（clip 区间内）。

意义：
- 避免“风险更高但报价更紧”的反常控制。

---

## 7. 回测实验设计（可直接执行）

## 7.1 研究问题

定义 5 个核心问题：
1. 联合策略相较 Naive/AS 是否提升风险调整收益？
2. 加入 circuit breaker 后是否降低尾部回撤？
3. regime detector 是否在高波动期显著改善表现？
4. adaptive hedger 是否降低 gamma 暴露和极端损失？
5. fast 版在接近表现下是否显著降低延迟与抖动？

## 7.2 数据与样本设计

最小字段：
- `timestamp`
- `price`
- `volume`（可选但建议）

建议扩展字段：
- order book top-N
- trade side
- implied vol / greeks

时间切分：
1. 训练窗口 \(W_{train}\)（用于 ML/RL 或参数估计）
2. 验证窗口 \(W_{val}\)
3. 测试窗口 \(W_{test}\)

采用 rolling walk-forward：
- 例：训练 60 天，验证 20 天，测试 20 天，步长 20 天滚动。

## 7.3 实验组与对照组

基线组：
- `NaiveMarketMaker`
- `AvellanedaStoikov`

实验组：
- `IntegratedMarketMakingStrategy`
- `FastIntegratedMarketMakingStrategy`
- `XGBoostSpreadStrategy`（若已训练）
- `PPOMarketMaker`（若已训练）

消融矩阵（建议必做）：
1. Integrated - circuit breaker
2. Integrated - regime detector
3. Integrated - adaptive hedger
4. Integrated only AS core
5. FastIntegrated cache on/off

## 7.4 参数网格

建议从以下子集开始：
- `base_spread_bps`: [10, 20, 30]
- `inventory_limit`: [5, 10, 20]
- `gamma`: [0.05, 0.1, 0.2]
- circuit loss limit: [5%, 10%]
- regime multipliers: LOW/MED/HIGH 的 3 组组合
- hedger base interval: [10, 30, 60] 分钟

控制变量原则：
- 每次只改变一个模块参数组，避免交互效应污染解释。

## 7.5 指标体系（必须同时看）

收益类：
\[
\text{TotalPnL},~\text{AnnualizedReturn}
\]

风险类：
\[
\text{Sharpe} = \frac{\mu_r-r_f}{\sigma_r}\sqrt{A},
\quad
\text{MaxDD} = \max_t\frac{\text{Peak}_t-\text{Equity}_t}{\text{Peak}_t}
\]

交易质量类：
- Win rate
- Profit factor
- Fill rate
- Adverse selection cost
- Inventory cost

风控行为类：
- 熔断触发次数
- 各状态停留时间占比
- 对冲次数与平均对冲量

稳定性类：
- 指标在不同窗口的方差
- 极端行情子样本表现

## 7.6 统计检验设计

建议至少三层：
1. 配对检验：同一窗口同一数据上策略 A vs B 的差值序列。
2. Welch t-test：项目已有 `StrategyArena.statistical_comparison`。
3. Block bootstrap 置信区间：应对收益自相关。

多重比较校正：
- Bonferroni（项目已有）或 FDR。

显著性报告应包含：
- 均值差
- 95% CI
- p-value
- 效应量（Cohen’s d 或收益差占风险单位）

## 7.7 压力测试设计

使用 `StressTest.SCENARIOS` 并扩展：
- `market_crash`
- `vol_spike`
- `liquidity_crisis`
- `flash_crash`

自定义场景建议：
1. 单日 -30% 跳空 + IV +120%
2. 连续 5 天高波动（vol cluster）
3. 流动性骤降（盘口深度衰减 70%）

输出：
- 场景 PnL
- 占组合净值百分比
- 熔断状态轨迹
- 对冲触发轨迹

## 7.8 防止回测偏差（必须执行）

1. 防前视：
- 生成 quote 只用当前或滞后信息。
- 训练样本特征窗口严格在标签窗口之前。

2. 防幸存者偏差：
- 包含退市/无流动性阶段样本。

3. 防过拟合：
- 不把测试集用于参数调优。
- 使用多个市场周期做外样本。

4. 成本模型真实化：
- 滑点、延迟、部分成交、手续费全部进模型。

5. 随机性控制：
- 固定 random seed，重复多次运行取均值与置信区间。

---

## 8. 项目内可复现实验协议（建议直接落地）

### 8.1 协议 A：标准组对比

目标：验证联合策略是否显著优于 Naive/AS。

步骤：
1. 使用同一份 `market_data`。
2. 在 `StrategyArena` 中跑 3 个策略：Naive、AS、Integrated。
3. 输出比较表、统计检验表、图表。
4. 报告 10 个核心指标并解释异常窗口。

判定标准：
- Integrated 的 Sharpe 与 MaxDD 同时优于至少一个基线。
- 熔断触发次数可解释，不出现频繁误触发。

### 8.2 协议 B：风控消融

目标：量化每个风控组件的边际价值。

步骤：
1. 构造 4 个版本（全开、去熔断、去 regime、去 hedger）。
2. 在相同窗口重复实验。
3. 比较 tail 指标：CVaR、worst day、max drawdown。

判定标准：
- 去掉组件后 tail 指标显著恶化，才证明该组件真有价值。

### 8.3 协议 C：低延迟取舍

目标：评估 fast 版“性能换精度”是否可接受。

步骤：
1. 比较 Integrated vs FastIntegrated。
2. 同时记录：PnL、Sharpe、MaxDD、avg latency、fallback ratio。
3. 统计 fallback ratio 与绩效下降的相关性。

判定标准：
- 若收益风险指标下降有限，而延迟显著改善，可用于实盘热路径。

### 8.4 协议 D：Hawkes 做市策略对比实验

目标：验证 Hawkes 过程建模在订单流聚类市场的优势。

理论假设：
- 高聚类市场（分支比 \(\alpha/\beta > 0.6\)）中，Hawkes 策略 Sharpe 比 AS 高 20%+
- 强度-价差相关系数为负（高强度时收窄价差）
- Adaptive 版本在 regime 变化时表现优于固定参数版本

步骤：
1. **场景生成**：
```python
from research.backtest.hawkes_comparison import ScenarioGenerator

gen = ScenarioGenerator(base_price=50000.0)
scenarios = gen.generate_hawkes_scenarios(seed_offset=0)
# 包含：low_clustering, medium_clustering, high_clustering, critical
```

2. **策略配置**：
```python
strategies = [
    HawkesMarketMaker(HawkesMMConfig()),           # 固定参数
    AdaptiveHawkesMarketMaker(HawkesMMConfig()),   # 自适应参数
    AvellanedaStoikov(ASConfig()),                 # 基准 1
    ASWithVolatilityAdaptation(ASConfig()),        # 基准 2
    XGBoostSpreadStrategy(XGBoostSpreadConfig()),  # ML 基准
    NaiveMarketMaker(NaiveMMConfig()),             # 简单基准
]
```

3. **运行对比**：
```python
comparison = ComprehensiveHawkesComparison(
    initial_capital=100000.0,
    transaction_cost_bps=2.0
)
results = comparison.run_full_comparison(strategies, scenarios)
```

4. **专项指标分析**：
- 强度-价差相关系数（预期为负）
- 参数稳定性（Adaptive 版本）
- 逆向选择检测准确率
- 不同聚类程度下的相对表现

判定标准：
- 高聚类场景中 Hawkes Sharpe 显著高于 AS（Welch's t-test, p < 0.05）
- 强度-价差相关性为负且显著
- Adaptive 版本在 critical 场景下表现更稳定

压力测试：
- `volume_spike`：验证对突发交易量的响应速度
- `liquidity_drought`：验证极端低流动性下的稳定性
- `inventory_stress`：验证库存管理能力

---

## 9. 模块级实践导读（策略 x 风控）

### 9.1 `research/risk/circuit_breaker.py`

学习重点：
1. `PortfolioState` 各属性如何构造风险量。
2. `_check_all_limits` 的违规定义与阈值设计。
3. `_determine_state` 的状态转移逻辑。
4. `can_trade` 如何把状态映射为动作约束。

实践建议：
- 修改 warning/critical 阈值，观察状态分布变化与 PnL tail 的变化。

### 9.2 `research/hedging/adaptive_delta.py`

学习重点：
1. 时间触发 + delta 偏离触发 + 紧急等级触发的并联结构。
2. `_calculate_adjusted_interval` 与 `_calculate_hedge_size` 的非线性。
3. inverse 标志对对冲规模的价格依赖修正。

实践建议：
- 在同一数据上比较 `AdaptiveDeltaHedger` 与 `SimpleDeltaHedger`。

### 9.3 `research/signals/regime_detector.py` / `fast_regime_detector.py`

学习重点：
1. HMM 的拟合、预测、失败降级。
2. fast 版的异步训练与超时回退。
3. `get_spread_adjustment` 如何连接到策略报价。

实践建议：
- 统计 `fallback_ratio` 与 `spread_multipliers` 实际触发频率。

### 9.4 `strategies/market_making/integrated_strategy.py`

学习重点：
1. `quote` 是统一调度器。
2. `_calculate_reservation_price` 的库存偏移机制。
3. `_calculate_quote_sizes` 的边界裁剪。
4. `on_fill` 与 `_realized_pnl` 的更新路径。

实践建议：
- 对同一时刻输入，固定其余变量，单独扫描 inventory 对报价的影响曲线。

### 9.5 `strategies/market_making/fast_integrated_strategy.py`

学习重点：
1. Greeks 缓存策略（TTL + 容量上限）。
2. 乘法式 spread multiplier 与 clip。
3. 性能统计 `get_performance_stats`。

实践建议：
- 调整 `greeks_cache_ttl_ms` 看命中率与性能变化。

### 9.6 `strategies/market_making/hawkes_mm.py`

学习重点：
1. `HawkesIntensityMonitor` 类实现：条件强度计算、参数在线估计。
2. `_compute_dynamic_spread`：基于强度的高阶动态价差调整机制。
3. `_compute_inventory_skew`：买卖强度不平衡驱动的库存偏斜。
4. `_detect_adverse_selection`：启发式逆向选择检测逻辑。
5. `AdaptiveHawkesMarketMaker`：参数自适应更新机制。

核心公式映射：
- `monitor.intensity(t)` → 公式：\(\lambda(t) = \mu + \sum \alpha e^{-\beta(t-t_i)}\)
- `_compute_dynamic_spread` → 公式：强度阈值驱动的三级价差调整
- `_compute_inventory_skew` → 公式：\(\Delta_{skew} \propto q_t \cdot \frac{\lambda^{buy} - \lambda^{sell}}{\lambda^{buy} + \lambda^{sell}}\)

实践建议：
- 对比固定参数 vs Adaptive 版本在不同聚类程度市场的表现。
- 验证强度-价差相关系数是否为负（理论预期）。
- 统计逆向选择检测的准确率与误报率。

### 9.7 `research/backtest/hawkes_comparison.py`

学习重点：
1. `ScenarioGenerator`：合成 Hawkes 数据与压力测试场景生成。
2. `HawkesMetricsCollector`：专项指标收集（强度-价差相关性、参数稳定性）。
3. `ComprehensiveHawkesComparison`：多策略多场景批量对比框架。
4. 统计显著性检验：Welch's t-test + Bonferroni 校正。

实践建议：
- 运行完整对比实验，验证高聚类场景下 Hawkes 优势。
- 调整 Hawkes 参数（\(\mu, \alpha, \beta\)），观察对结果的影响。
- 使用 Jupyter Notebook 进行交互式参数探索。

### 9.8 `research/backtest/engine.py` + `arena.py`

学习重点：
1. `run` 的事件循环与无前视处理。
2. fill 仿真与滑点模型。
3. scorecard 统计口径与比较方法。

实践建议：
- 固定随机种子 + 改变 fill 参数，观察策略排名是否稳定。

---

## 10. 工程落地：从研究原型到可运行系统

### 10.1 生产可用的最小闭环

1. 数据输入稳定：
- streaming 异常可恢复
- 缓存层可降级

2. 策略输出可控：
- 无论何种异常，返回合法 `QuoteAction`
- 风控拒绝时输出零 size

3. 风控状态可观测：
- 熔断状态、违规明细、恢复进度可查询

4. 验证与监控：
- 单测 + 回测回归 + 延迟监控

### 10.2 可观测性指标建议

必须打点：
- `quote_latency_ms`
- `spread_bps`
- `inventory`
- `circuit_state`
- `regime`
- `hedge_trigger_count`
- `fallback_ratio`
- `cache_hit_rate`

建议报警：
- HALTED 进入
- fallback_ratio 突升
- latency P99 超阈值
- 连续异常输入数据

### 10.3 风险分层防御

建议三层：
1. 预交易：`can_trade`、库存上限、价差下限。
2. 交易中：自适应对冲、regime 扩价、延迟降级。
3. 交易后：VaR/CVaR、压力测试、回测回归。

---

## 11. 30 天深度学习与实战路线

第 1 周：数学打底
1. 手推 inverse PnL、AS 保留价、半价差分解。
2. 手推 Hawkes 过程强度函数、买卖分离双变量模型、动态价差公式。
3. 对照 `inverse_options.py`、`avellaneda_stoikov.py`、`hawkes_mm.py`。
4. 写出自己的量纲检查表。

第 2 周：算法联调
1. 跑 Integrated 并打印每步 metadata。
2. 观察 regime/circuit/hedger 如何共同改变报价。
3. 做最小消融：去掉一个组件重跑。

第 3 周：回测实验
1. 建立 walk-forward 实验脚手架。
2. 完成基线、实验组、消融组。
3. 输出统计检验与显著性结论。
4. 运行 Hawkes 对比实验（协议 D），验证高聚类市场优势。
5. 分析强度-价差相关性与逆向选择检测效果。

第 4 周：工程强化
1. 增加可观测性指标。
2. 做压力场景回归测试。
3. 形成策略参数“安全默认值”文档。

---

## 12. 常见误区与纠偏

1. 误区：只追求 PnL 最大化。
- 纠偏：联合看 Sharpe、MaxDD、tail 指标和状态机稳定性。

2. 误区：把风控当后处理。
- 纠偏：风控要进入控制律与动作可行域。

3. 误区：把 fast 版当“同等精度更快”。
- 纠偏：fast 是“受控近似”，必须量化精度-延迟 tradeoff。

4. 误区：把训练集表现当生产能力。
- 纠偏：必须看滚动外样本 + 压力测试 + 多随机种子。

5. 误区：忽视量纲。
- 纠偏：币本位下 Delta/Gamma 转 USD 时必须做维度变换。

---

## 13. 附录 A：关键公式清单（便于速查）

1. 币本位未实现盈亏：
\[
\mathrm{PnL}_{inv}=q\left(\frac{1}{S_{entry}}-\frac{1}{S_t}\right)
\]

2. AS 保留价：
\[
r_t = S_t - q_t\gamma\sigma^2(T-t)
\]

3. AS 半价差：
\[
\delta_t=\frac{1}{2}\gamma\sigma^2(T-t)+\frac{1}{\gamma}\ln\left(1+\frac{\gamma}{k}\right)
\]

4. 联合 spread：
\[
\text{spread}_t = \text{base\_spread}\times m_t
\]
标准版 \(m_t=\max(m_t^{regime},m_t^{circuit})\)，快版 \(m_t=m_t^{regime}m_t^{circuit}\) 再 clip。

---

## 13.1 Hawkes 做市策略公式扩展

### 13.1.1 Hawkes 过程基础

Hawkes 过程（自激励点过程）的强度函数：
\[
\lambda(t) = \mu + \sum_{t_i < t} \alpha e^{-\beta(t - t_i)}
\]

其中：
- \(\mu\)：基线强度（背景到达率）
- \(\alpha\)：激励因子（一个事件引发的新事件期望数）
- \(\beta\)：衰减率（激励效果消失速度）
- 稳定性条件：\(\alpha < \beta\)（分支比 \(\frac{\alpha}{\beta} < 1\)）

长期平均强度（平稳状态）：
\[
\lambda^* = \frac{\mu}{1 - \frac{\alpha}{\beta}} = \frac{\mu\beta}{\beta - \alpha}
\]

### 13.1.2 买卖分离的双变量 Hawkes

做市策略区分买单流和卖单流：

\[
\begin{aligned}
\lambda^{buy}(t) &= \mu^{buy} + \sum_{t_i^{buy} < t} \alpha^{buy} e^{-\beta(t - t_i^{buy})} + \sum_{t_i^{sell} < t} \alpha^{cross} e^{-\beta(t - t_i^{sell})} \\
\lambda^{sell}(t) &= \mu^{sell} + \sum_{t_i^{sell} < t} \alpha^{sell} e^{-\beta(t - t_i^{sell})} + \sum_{t_i^{buy} < t} \alpha^{cross} e^{-\beta(t - t_i^{buy})}
\end{aligned}
\]

\(\alpha^{cross}\) 表示跨方向激励（买单引发卖单的概率）。

### 13.1.3 动态价差公式

Hawkes MM 的价差调整基于强度：

**基础价差：**
\[
\text{spread}_{base} = \text{base\_spread\_bps} \times S_t \times 10^{-4}
\]

**强度调整因子：**
\[
m_t^{intensity} = \begin{cases}
\text{aggressive\_factor} & \text{if } \lambda(t) > \text{high\_intensity\_threshold} \\
1.0 & \text{if } \text{low\_threshold} \leq \lambda(t) \leq \text{high\_threshold} \\
\text{defensive\_factor} & \text{if } \lambda(t) < \text{low\_intensity\_threshold}
\end{cases}
\]

**最终价差：**
\[
\text{spread}_t = \text{clip}\left(\text{spread}_{base} \times m_t^{intensity} \times m_t^{inventory}, \text{min\_spread}, \text{max\_spread}\right)
\]

### 13.1.4 库存偏斜（Inventory Skew）

基于买卖强度不平衡的报价调整：

\[
\Delta_{skew} = \text{inventory\_skew\_factor} \times q_t \times \frac{\lambda^{buy}(t) - \lambda^{sell}(t)}{\lambda^{buy}(t) + \lambda^{sell}(t)}
\]

**买单强度 > 卖单强度**（预期价格上涨）：
- 提高卖价（ask），降低买价（bid）
- 鼓励卖出，抑制买入

**卖单强度 > 买单强度**（预期价格下跌）：
- 降低卖价（ask），提高买价（bid）
- 鼓励买入，抑制卖出

### 13.1.5 逆向选择检测

检测有毒订单流的条件概率模型：

\[
P(\text{adverse} \mid \text{trade}) = \frac{\lambda^{informed}}{\lambda^{informed} + \lambda^{uninformed}}
\]

启发式检测规则（实现中）：
\[
\text{is\_adverse} = \begin{cases}
\text{True} & \text{if } |\Delta P| > \text{adverse\_selection\_threshold} \times \sigma \text{ and } \lambda(t) > \bar{\lambda} \\
\text{False} & \text{otherwise}
\end{cases}
\]

其中 \(\Delta P\) 为成交后价格变动，\(\bar{\lambda}\) 为近期平均强度。

### 13.1.6 自适应参数更新（Adaptive 版本）

在线矩估计更新规则：

\[
\begin{aligned}
\hat{\mu}_{t+1} &= \hat{\mu}_t + \eta \left(\frac{N_t}{T_t} - \hat{\mu}_t\right) \\
\hat{\alpha}_{t+1} &= \hat{\alpha}_t + \eta \left(\frac{\sum_{i} e^{-\hat{\beta}(t - t_i)}}{N_t} - \hat{\alpha}_t\right) \\
\hat{\beta}_{t+1} &= \text{argmax}_{\beta} \sum_{t_i} \ln \lambda(t_i; \beta)
\end{aligned}
\]

学习率 \(\eta = \frac{1}{\text{update\_interval}}\)，通常每 50 笔交易更新一次。

### 13.1.7 Hawkes 专项评估指标

**强度-价差相关系数：**
\[
\rho_{\lambda, spread} = \frac{\text{Cov}(\lambda_t, \text{spread}_t)}{\sigma_{\lambda} \sigma_{spread}}
\]

理论预期：\(\rho < 0\)（高强度时收窄价差）

**参数稳定性：**
\[
\text{stability} = 1 - \frac{\text{Std}(\alpha_t)}{\text{Mean}(\alpha_t)}
\]

稳定性 > 0.8 视为良好收敛。

**逆向选择检测准确率：**
\[
\text{Accuracy} = \frac{\text{TP} + \text{TN}}{\text{TP} + \text{TN} + \text{FP} + \text{FN}}
\]

目标：> 60%（显著优于随机猜测）。

5. 最大回撤：
\[
\mathrm{MDD}=\max_t\frac{\mathrm{Peak}_t-\mathrm{Equity}_t}{\mathrm{Peak}_t}
\]

6. Sharpe：
\[
\mathrm{Sharpe}=\frac{\mathbb{E}[r-r_f]}{\mathrm{Std}(r)}\sqrt{A}
\]

7. CVaR：
\[
\mathrm{CVaR}_{\alpha}=\mathbb{E}[L\mid L\ge \mathrm{VaR}_{\alpha}]
\]

---

## 14. 附录 B：建议读码顺序（函数级）

第一层（主干控制流）：
1. `strategies/market_making/integrated_strategy.py:quote`
2. `research/risk/circuit_breaker.py:check_risk_limits`
3. `research/signals/regime_detector.py:update`
4. `research/hedging/adaptive_delta.py:should_hedge`
5. `research/backtest/engine.py:run`

第二层（核心公式实现）：
1. `research/pricing/inverse_options.py:calculate_price`
2. `research/pricing/inverse_options.py:calculate_greeks`
3. `strategies/market_making/avellaneda_stoikov.py:quote`
4. `strategies/market_making/hawkes_mm.py:quote`（Hawkes 过程做市）
5. `strategies/market_making/hawkes_mm.py:_compute_dynamic_spread`（动态价差）
6. `strategies/market_making/hawkes_mm.py:_compute_inventory_skew`（库存偏斜）

第三层（评估与统计）：
1. `research/backtest/arena.py:_calculate_scorecard`
2. `research/backtest/arena.py:statistical_comparison`
3. `research/backtest/hawkes_comparison.py:ComprehensiveHawkesComparison`（Hawkes 对比框架）
4. `research/backtest/hawkes_comparison.py:HawkesMetricsCollector`（专项指标收集）
5. `research/risk/var.py:parametric_var/historical_var/monte_carlo_var`

---

## 15. 结语：真正的“联合推导”标准

当你能做到以下三件事，才算真正掌握本项目的策略-风控联合体系：
1. 给定一次异常交易日，能从 `quote -> risk gate -> fill -> pnl` 逐函数解释结果。
2. 修改一个参数（如 `gamma` 或 `daily_loss_limit_pct`）后，能预判其数学和工程后果，并被回测验证。
3. 能把“收益提升”与“风险边界”同时写成可验证实验，而不是靠叙述。

这就是从“会用策略”到“会设计系统”的分水岭。

